# BOM이란   
BOM이란 문서 맨 앞에 눈에 보이지 않는 특정 바이트(byte)를 넣은 다음 이것을  
해석해서 정확히 어떤 인코딩 방식이 사용되었는지 알아내는 방법을 나타낸다.  
자세하게 유니코드가 little-endian 인지 big-endian인지 아니면 UTF-8인지 쉽게  
알 수 있도록, 유니코드 파일이 시작되는 첫 부분에 보이지 않게, 2 ~ 3 바이트의  
문자열을 추가하는데 이 것을 BOM이라고 한다. BOM은 텍스트 에디터 화면에서는  
보이지 않고, 헥사 에디터(Hex Editor)로 열었을 때만 보인다.  

---

# 아스키코드? 유니코드가 뭐지?  
-  컴퓨터가 처음 발명되었을 때 표현 가능한 문자는 128개였다. 이를 ASCII 코드라고  
한다. 영어 알파벳과 통화를 포함한 여러 기호를 표현할 수 있었기에 미국을 중심으로  
한 영어권에서는 사용하는 데 아무 문제가 없었다.  
- 컴퓨터가 보다 대중화되면서 대부분의 서유럽 언어의 알파벳을 추가하여 256개의  
문자를 표현할 수 있게 되었다. 이를 ISO-8859-1 코드라고 한다. 유명한 오픈 소스  
서블릿 컨테이너인 Apache Tomcat의 기본 언어 코드가 바로 ISO-8859-1이다.  
이 문제로 쿼리 스트링에 포함된 한글 문자열이 깨지는 것을 누구나 경험해봤을  
것이다. 초창기 HTML의 표준 언어 코드였기 때문에 아직도 서유럽의 적지 않은  
웹사이트들이 이 코드로 제공된다.  
- 초창기 컴퓨터 산업은 미국을 비롯한 서유럽이 이끌었기에 아무 문제가 없었다.   
문제는 그 외의 다른 언어를 사용하는 지역이다. 결국 독자적인 코드를 만들어   
사용하게 된다. 한국의 경우 KSC5601-1987을 사용했다.   
- Unicode(유니코드)는 파편화된 전 세계의 언어 코드를 하나의 코드로 통일하기  
위해 나왔다. 유니코드는 총 1,114,112개의 문자를 표현할 수 있다. Plane이라   
불리는 17개의 영역이 각각 65536개의 문자를 표현할 수 있으며 이모티콘(Emoji)  
또한 개별 유니코드 문자로 제공한다.   

---

# 유니코드란 무엇일까? (UTF-8과 EUC-KR 비교)   
유니코드는 다국어를 지원하는 프로그래밍을 하다보면 가장 먼저 접하는 어려움이다.   
일단 유니코드라는 용어의 개념부터 정리해보도록 하자. 조금 공부한 사람들은   
ASCII, EUC-KR, CP949, UTF8, UTF16같은 것들을 알고 있을 것이다.  
  
그럼 문제, 이 중에 뭐가 유니코드(Unicode)일까?   
이 중에 유니코드 그 자체인 것은 없다. 그나마 UTF-8, UTF-16에는 50점 줄 수 있을   
것 같다. 이들은 유니코드를 '사용'하는 인코딩 방식이기 때문이다. EUC-KR도, CP  
949가 유니코드가 아닌가?라고 생각하는 사람도 있을 것이고, 유니코드란 2바이트로  
표현하는 문자셋이 아닌가?라고 알고 있는 사람들도 있을 것이다.   
  
이제는 잊어야 한다. 만약 지금 헷갈리고 있다면 "유니코드"와 "인코딩 방식"을  
헷갈리고 있는 것이다.   

# 그럼 유니코드란 무엇일까?   
유니코드란, 숫자와 글자, 즉 키와 값이 1:1로 매핑된 형태의 코드인 것이다.  
  
**다시 말해 아스키 코드로 0x41 = A(16진수)로 매핑된 것처럼, 아스키 코드도 표현할  
수 없는 문자들을 유니코드라는 이름 아래 전 세계의 모든 문자를 특정 숫자(키)와   
1:1로 매핑한 것이다.**       
  
전 세계의 모든 문자가 너무 많을 것 같다. 하지만 유니코드는 현재 2<sub>20</sub> +  
2<sub>16</sub> 개수 만큼의 공간을 사용하고 있어서 웬만큼은 다 담겨있다. 특히   
한자의 총 개수가 10만여자가 될 것이라고 추정하는데, 모든 한자를 담고 있지 못하다는   
것을 빼면 전 세계 대부분의 문자가 전부 유니코드에 담겨 있다고 봐도 될 것이다.   
우리가 사용하는 한글의 경우에는 조합형을 위한 자모와, 완성형 한글이 모두 포함  
되어 있다.   

유니코드는 너무 많아서 아스키 코드표처럼 한 눈에 들어오는 테이블은 만들기 어렵다.   
그래서 블록을만 나누어 놓은 테이블도 상당하다.  
  
`U+`라는 접두어가 붙어있으면 유니코드라는 의미이다. 아스키코드의 0x41은 대문자   
A이고, 이를 유니코드표에서 찾으면 U+0041이 된다.  
  
위에 언급한 UTF-8, UTF-16같은 인코딩 방식은 이 유니코드의 숫자 키들을 어떻게  
표현하느냐에 따라 달린 것이다. 예를 들어 UTF-8은 가변 바이트를 사용하기 때문에,   
1바이트로 표현이 충분한 A같은 경우는 0x41로 표현한다. 반면 UTF-16은 16비트 즉,    
2바이트로 표현하기 때문에, 0x0041로 표현한다. UTF-32도 있는데, 4바이트로 표현하기   
때문에 0x00000041이 된다(이렇게 될 것 같지만, UTF16과 UTF32의 인코딩 방식의   
표현 방법에 따라 조금 다르다).  
- 추가내용1: UTF16은 Little-Endian이냐, Big-Endian이냐에 따라 0x4100이 될 수도,  
0x0041이 될 수도 있다.   
- 추가내용2: UTF32 역시 LE냐 BE냐에 따라 0x4100 0000 이거나 0x0000 0041이 된다.   
따라서 UTF-8의 표현 방식이 대체로 더욱 효율적이다. 세계적으로 UTF-8표준으로 많이   
쓰이는 추세이다.   

# 그럼 EUC-KR, CP949는 무엇인가?   
이 두가지 인코딩 방식은 2바이트로 한글을 표현할 수 있게 만든 방식이다. 일부 한자  
등도 포함된다. 아스키 값은 그대로 1바이트로 표현된다.   
  
오래전부터 쓰이던게 EUC-KR이고, 이 인코딩에서 표현할 수 없는 한글이 있어 마이크로   
소프트에서 코드페이지 949를 사용하기 시작한다. CP949는 EUC-KR보다 더 많은  
한글을 표현할 수 있으며, 윈도우에서 주로 쓰이는 인코딩 기법이다. CP949를  
EUC-KR의 확장이라고 보면 될 것이다.   




  

---
# 문자 인코딩
줄여서 인코딩은 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로   
만드는 것을 말한다. 즉, 복잡한 신호를 0과 1의 디지털 신호(2진수)로 변환하는 것을  
의미한다.   

# 아스키 코드
아스키는 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며,  
대부분의 문자 인코딩이 아스키에 기초를 두고 있다.  
  
아스키는 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한  
문자들로 000(0x00)부터 127(0x7F)까지 총 128개로 이루어진다(20진법도 아니고   
10진법도 아닌 어중간한 16진법을 컴퓨터 분야에서 사용하는 이유는 16진수 자릿수   
하나가 2<sub>4</sub>을 표현할 수 있기 때문이다. 전자 기기, 특히 컴퓨터에서   
사용하는 이유는 자릿수 2개를 사용하면 2<sub>8</sub>을 표현할 수 있는데, 2  
<sub>8</sub>은 곧 1바이트이다. 간단히 1바이트의 값을 2진법을 사용해서 0101    
1111 식으로 표기할 게 아니라 그냥 16진법으로 5F<sup>16</sup>라고 표기해 버리면   
많이 축약할 수 있다.).  
아스키는 2바이트 이상의 다양한 코드들을 표현할 수 없기 때문에 현대에는 유니코드  
(Unicode)를 더 많이 사용한다.   
참고로 유니코드는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수    
있도록 설계된 산업 표준이다.   
우리가 핸드폰에서 문자 텍스트를 칠 때 한 글자당 2byte로 처리되는 이유가 바로   
유니코드를 사용하기 때문이다.   


# UTF-8, EUC-KR의 비교  
한번 예제를 통하여 UTF-8과 EUC-KR을 간단하게 비교하는 실습을 해보도록 하자.   
우분투 14.04에서 실습)   
```
안abcd녕?  
```
리눅스에서 vi를 통해 위 글자를 입력한 후 저장하자. 시스템의 기본 설정이나, vi의   
fileencoding 설정에 따라서 저장되는 인코딩 방식이 다를 것이다.   
  
파일의 인코딩을 확인하는 방법은 아래와 같다.   
```
$ file -i test
test: text/plain; charse=utf-8
```
utf-8로 저장된 test 파일을 xxd라는 16진수 뷰어로 열어보자.   
```
$ xxd test
00000000: ec95 8861 6263 64eb 8595 3f0a     ...abcd...?.
```
utf-8은 유니코드를 사용하는 인코딩 방식이라 했다. 그럼 유니코드표를 보고   
비교하면 된다.   
  
유니코드표에서 '안'을 찾아보면 U+C548에 위치하고 있다.   
- 참조: http://ko.wikipedia.org/wiki/유니코드_C000%7ECFFF

이 U+C548이라는 키를 2진법으로 표현하는 방법이 인코딩 방식인 것이고, 이 중에   
하나가 UTF-8인 것이다.   
  
먼저 C548을 2진수로 풀면 아래와 같다.   
```
16진수 :   C    5    4    8
  2진수: 1100 0101 0100 1000 
```
그리고 이 한글 유니코드 블록은 UTF-8에서 3바이트로 표현된다. 이 코드를 UTF-8식으로   
표현하면 위에 C548의 이진수 값이 아래 빨간색의 영역에 차곡차곡 들어가서 아래와   
같이 된다.   
```
2진수 : 1110 [1100] 10[01 0101] 10[00 1000]
16진수:  E     C      9    5     8     8
```
EC9588, 다시 위의 헥사값과 비교해보면 정확히 앞의 3바이트와 일치하는 것을 알 수  
있다. 뒤에 61 62 63 64는 a, b, c, d의 1바이트 아스키 코드의 헥사값과 일치한다.   
그리고 eb 85 95는 '녕'을 의미함을 알 수 있을 것이다.   
- 참조   
   - 3f: ?의 아스키
   - 0a: LF(Line Feed)   
그럼 이제부터는 EUC-KR식의 표현방법을 보도록 하자. 먼저 utf-8로 저장된 test파일을   
euckr로 변환해야 한다. iconv 명령어를 이용해 변환하도록 한다. 아래와 같이 입력한다.   
```
$ iconv -f utf8 -t euckr test > test-euckr
```
그리고 아까와 같이, euckr로 변환된 텍스트의 헥사값을 본다.   
```
$ xxd test-euckr
00000000: bec8 6162 6364 b3e7 3f0a         ...abcd..?.
```
EUC-KR의 인코딩에는 UTF인코딩처럼 유별난 규칙은 없다 아스키 코드와 같이 그냥   
EUC-KR 코드표에서 매칭되는 값을 찾으면 된다.   
  
EUC-KR 코드표에서 '안'을 찾으면 bec8로 나온다. '녕'은 b3e7에 매핑되어 있다.   

# 정리하기
- 아스키 코드의 경우, 128개의 코드가 정리되어 있는 코드표가 있다.  
- EUC-KR/CP949의 경우, 2바이트로 표현할 수 있는 코드표가 있는 것이다.  
- UTF-8/UTF-16등의 인코딩은 U+로 시작되는 코드표가 존재하고, 이를 유니코드라고   
말한다. UTF같은 인코딩은 같은 유니코드표를 가지고 다르게 표현하는 방법인 것이다.  
(참조: 위의 '안'을 UTF16LE로 표현하면 ff fe 48 c5가 된다. 물론 유니코드표에서   
찾으면 U+C548로 같다. UTF-16은 2바이트라고 했는데 왜 4바이트일까? 이것은 추후  
다룰 UTF-16 인코딩 방식의 특성 때문이다).  
추가내용: UTF-16과 UTF-32 인코딩은 LE(Little-Endian) 또는 BE(Big-Endian)과  
같은 엔디안 속성을 가진다. ff fe라는 문자열을 통해 이 인코딩이 LE인지 BE인지   
구별하게 된다. Big-Endian의 경우에는 FE FF로 표현하고 Little-Endian의 경우에는  
FF FE로 표현한다. 참고로 UTF-32는 4바이트로 표현해야 하기 때문에, 이 마저도   
4바이트 (FFFF 0000)로 표현된다.   



---
  























