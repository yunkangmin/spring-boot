# DynamoDBAttribute
속성을 테이블 속성으로 매핑한다. 기본적으로 각 클래스 속성은 이름이 동일한   
항목 속성으로 매핑된다. 하지만 이름이 다를 경우에는 이 주석을 사용하여 클래  
스 속성을 테이블 속성으로 매핑할 수 있다.  아래 Java 코드에서는 DynamoDBAtt
ribute가 BookAuthors 속성을 테이블의 Authors 속성 이름으로 매핑하고 있다.
```java
@DynamoDBAttribute(attributeName = "Authors")
public List<String> getBookAuthros() { return BookAuthros; }
public void setBookAuthors(List<String> BookAuthors) { this.BookAuthors = BookAuthors; }
```

# DynamoDBDocument
해당 클래스를 DynamoDB 문서(로우)로 직렬화할 수 있음을 나타낸다.     
   
예를 들어, JSON 문서를 Map 형식(M)의 DynamoDB 속성으로 매핑하려는 경우  
다음 코드 예제에서는 Map 유형의 중첩된 속성(Pictures)을 포함하는 항목을  
정의한다.   
```java
public class ProductCatalogItem {
  private Integer id; //partition key
  private Pictures pictures;
  ...
  
  @DynamoDBHashkey(attributeName="Id")
  public Integer getId() { return id; }
  public void setId(Intenger id) { this.id = id; }
  
  @DynamoDBAttribute(attributeName="Pictures")
  public Pictures getPictures() { return pictures; }
  public void setPictures(pictures pictures) { this.pictures = pictures; }
  
  ...
  
  @DynamoDBDocument
  public static class Pictures {
    private String frontView;
    private String rearView;
    private String sideView;
    
    @DynamoDBAttribute(attributeName = "FrontView")
    public String getFrontView() { return frontView; }
    public void setFrontView(String frontView) { this.frontView = frontView; }
    
    @DynamoDBAttribute(attributeName = "RearView")
    public String getRearView() { return rearView; }
    public void setRearView(String rearView) { this.rearView = rearView; }
    
    @DynamoDBAttribute(attributeName = "SideView")
    public String getSideView() { return sideView; }
    public String setSideView(String sideView) { this.sideView = sideView; }
    
}
```
그러면 다음 예제와 같이 새 ProductCatalog 항목을 Pictures와 함께 저장할  
수 있다.   
```java
ProductCatalogItem item = new ProductCatalogItem();

Pictures pix = new Pictures();
pix.setFrontView("http://example.com/products/123_front.jpg");
pix.setRearView("...");
pix.setSideView("...");

item.setId(123);

mapper.save(item);
```
결과로 얻은 productCatalog 항목은 다음과 같을 것이다(JSON 형식).  
```json  
{ 
  "Id" : 123
  "Pictures": {
    "SideView": "...",
    "RearView": "...",
    "FrontView": "..."
  }
}
```

# DynamoDBTyped
표준 속성 형식 바인딩을 재정의하는 주석 표준 형식에서 해당 형식에 기본   
속성 바인딩(String인듯)을 적용할 경우 주석이 필요하지 않다.   

# DynamoDBAutoGeneratedKey
파티션 키 또는 정렬 키 속성을 자동 생성되는 것으로 표시한다.   
DynamoDBMapper는 이러한 속성을 저장할 때 임의의 UUID를 생성한다.  
String 속성만 자동 생성된 키로 표시될 수 있다.   
  
다음 예제에서는 자동 생성된 키를 사용하는 방법을 보여준다.  
```java
@DynamoDBTable(tableName="AutoGeneratedKeysExample")
public class AutoGeneratedKeys {
   private String id;
   private String payload;
   
   @DynamoDBHashKey(attributeName = "Id")
   @DynamoDBAutoGeneratedkey
   public String getId() { return id; }
   public void setId(String id) { this.id = id; }
   
   @DynamoDBAttribute(attributeName="payload")  
   public String getPayload() { return this.payload = payload; }
   public void setPayload(String payload) { this.payload = payload; }
   
   public static void saveItem() {
      AutoGeneratedKeys obj = new AutoGeneratedKeys();
      obj.setPayload("abc123");
      
      //id field is null at this point
      DynamoDBMapper mapper = new DynamoDBMapper(dynamoDBClient);
      mapper.save(obj);
      
      System.out.println("Object was saved with id " + obj.getId());
   }
}
```

# DynamoDBTypeConverted
속성을 사용자 지정 유형 변환기를 사용하는 것으로 표시하는 주석 DynamoDB  
TypeConverter에 추가 속성을 전달하기 위한 사용자 정의 주석에 작성할 수  
있다.   
  
DynamoDBTypeConverter 인터페이스를 사용하면 자체적인 임의 데이터 형식을  
DynamoDB에서 기본적으로 지원되는 데이터 형식으로 매핑할 수 있다. 자세한  
내용은 섹션을 참조하자. [임의 데이터 매핑](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/DynamoDBMapper.ArbitraryDataMapping.html)  

# 임의 데이터 매핑
**지원되는 Java 형식([지원되는 데이터 형식](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/DynamoDBMapper.DataTypes.html)) 외에도 애플리케이션에서 직접적으로 Amazon DynamoDB  
형식에 매핑되지 않는 형식을 사용할 수 있다. 이러한 형식을 매핑하려면  
복합 형식을 DynamoDB 지원 형식으로 또는 그 반대로의 변환을 구현하고  
@DynamoDBTypeConverted 주석을 사용하여 복합 형식의 접근자 메서드에 주석을  
추가해야 한다. 이 후 객체를 저장하거나 로드하면 변환기 코드가 데이터를  
변환한다.** 그 밖에 복합 형식을 사용하는 모든 작업에서도 유용하다. 단,   
쿼리나 스캔 작업 중 데이터를 비교하면 DynamoDB에 저장된 데이터를 비교하게  
된다.   
  
아래에서 CatalogItem 속성, 즉 Dimension을 정의하고 있는 DimensionType  
클래스를 예로 들어보자. 이 속성에는 높이, 너비, 두께 등의 항목 차원이   
저장된다. DynamoDB에서 이 항목 크기를 문자열(8.5.x11x05)로 저장한다고  
가정할 때, 다음 예제를 보면 DimensionType 객체를 문자열로, 혹은 문자열을  
DimensionType으로 변환하는 변환기 코드가 나와있다.  

> #### 참고   
> 아래 코드 예제는 [DynamoDB에서 테이블 생성 및 코드 예제에 대한 데이터  
> 로드](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/SampleData.html) 단원의 지침에 따라 이미 계정의 DynamoDB에 데이터를 로드하였다고  
> 가정한 것이다.    
> 다음 예를 실행하기 위한 단계별 지침은 [Java 코드 예](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/CodeSamples.Java.html) 단원을 참조하세요.  

```java
public class DynamoDBMapperExample {
   
   //자바에서는 클래스 및 클래스 멤버의 접근 제어의 기본값으로  
   //default 접근제어를 별도로 명시하고 있다.  
   //이러한 default를 위한 접근 제어자는 따로 존재하지 않으며, 접근  
   //제어자가 지정되지 않으면 자동적으로 default 접근 제어를 가지게  
   //된다. default 접근 제어를 가지는 멤버는 같은 클래스의 멤버와  
   //같은 패키지에 속하는 멤버에서만 접근할 수 있다.  
   static AmazonDynamoDB client;
   
   public static void main(String[] args) throws IOException {
      
      //Set the AWS region you want to access.
      Regions usWest2 = Regions.US_WEST_2;
      client = AmazonDynamoDBClientBuilder.standard().withRegion(usWest2).build();
      
      DimensionType dimType = new DimensionType();
      dimType.setHeight("8.00");
      dimType.setLength("11.0");
      dimType.setThickness("1.0");
      
      Book book = new Book();
      book.setId(502);
      book.setTitle("Book 502");
      book.setISBN("555-55555555555");
      book.setBookAuthors(new HashSet<String>(Arrays.asList("Author1", "Author2")));
      book.setDimensions(dimType);
      
      DynamoDBMapper mapper = new DynamoDBMapper(client);
      mapper.save(book);
      
      Book bookRetrieved = mapper.load(Book.class, 502);
      System.out.println("Book info: " + "\n" + bookRetrieved);
      
      bookRetrieved.getDimensions().setHeight("9.0");
      bookRetrieved.getDimensions().setLength("12.0");
      bookRetrieved.getDimensions().setThickness("2.0");
      
      mapper.save(bookRetrived);
      
      bookRetrieved = mapper.load(Book.class, 502);
      System.out.println("Updated book info: " + "\n" + bookRetrieved);
   }
   
   @DynamoDBTable(tableName = "ProductCatalog")
   public static class Book {
      private int id;
      private String title;
      private String ISBN;
      private Set<String> bookAuthors;
      private DimensionType dimensionType;
      
      //Partition key
      @DynamoDBHashkey(attributeName = "Id")
      public int getId() {
         return id;
      }
      
      public void setId(int id) {
         this.id = id;
      }
      
      @DynamoDBAttribute(attributeName = "Title")
      public String getTitle() {
         return title;
      }
      
      public void setTitle(String title) {
         this.title = title;
      }
      
      @DynamoDBAttribute(attributeName = "ISBN")
      public String getISBN() {
         return ISBN;
      }
      
      public void setISBN(String ISBN) {
         this.ISBN = ISBN;
      }
      
      @DynamoDBAttribute(attributeName = "Authors")
      public Set<String> getBookAuthors() {
         return bookAuthors;
      }
      
      public void setBookAuthors(Set<String> bookAuthros) {
         this.bookAuthors = bookAuthors;
      }
      
      @DynamoDBTypeConverted(converter = DimensionTypeConverter.class)
      @DynamoDBAttribute(attributeName = "Dimensions")
      public DimensionType getDimensions() {
         return dimentionType;
      }
      
      @DynamoDBAttribute(attributeName = "Dimensions")
      public void setDimensions(DimensionType dimensionType) { 
         this.dimensionType = dimensionType;
      }
      
      @Override
      public String toString() {
         ...
      }
   }
   
   static public class DimensionType {
      
      private String length;
      private String height;
      private String thickness;
      
      public String getLength() {
         return length;
      }
      
      public void setLength(String length) {
         this.length = length;
      }
      
      public String getHeight() {   
         return height;
      }
      
      public void setHeight(String height) {
         this.height = height;
      }
      
      public String getThickness() {
         return thickness;
      }
      
      public void setThickness(String thickness) {
         this.thickness = thickness;
      }
   }
   
   //Converts the complex type DimensionTypep to a string and vice-versa.
   //복합 유형 DimensionTypep를 문자열로 또는 그 반대로 변환합니다.
   //DynamoDBTypeConverter<String, DimensionType> -> DimensionType을 String으로 변환
   static public class DimensionTypeConverter implements DynamoDBTypeConverter<String, DimensionType> {
      
      @Override
      public String convert(DimensionType object) {
         DimensionType itemDimensions = (DimensionType) object;
         String dimension = null;
         try {
            if (itemDimensions != null) {
               dimension = String.format("%s x %s x %s", itemDimensions.getLength(), itemDimensions.getHeight(),
               itemDimensions.getThickness());
            }
         }
         catch (Exception e) {
            e.printStackTrace();
         }
         return dimension;
      }
      
      //문자열을 DimensionType으로 변환. 
      @Override
      public DimensionType unconvert(String s) {
         DimensionType itemDimension = new DimensionType();
         try {
            if (s != null && s,length() != 0) {
               String[] data = s.split("x");
               itemDimension.setLength(data[0].trim());
               itemDimension.setHeight(data[1].trim());
               itemDimension.setThickness(data[2].trim());
            }
         }
         catch (Exception e) {
            e.printStackTrace();
         }
         
         return itemDimension;
      }
   }
}
```     
   
      
      
      
      





















