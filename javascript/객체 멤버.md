# 정리  
- 생성자 멤버는 인스턴스 멤버와 별도의 연상 배열 구조에서 관리되기  
때문에 다음과 같은 코드는 에러가 난다. 

- 멤버는 배열이기 때문에 이런 접근이 가능하다.

- 연상 배열 구조   
객체별로 자신에게 속한 멤버를 관리하는 내부적인 데이터 구조가 있다.   
요소의 순서가없다.

---

# 1. 객체 멤버 관리    
JS에서 객체의 멤버를 내부적으로 어떻게 관리하고 개발자가 어떻게 객체의 구조를  
편집할 수 있는지 알아보자.   

## 멤버구분   
먼저 관리 대상이 되는 멤버를 성격에 따라 구분해보자.   
  
앞에서 함수도 객체라 했으므로 생성자에도 멤버가 될 수 있다. 이처럼 생성자에   
정의된 멤버를 이 책에서는 생성자 멤버라 한다. 생성자 멤버는 함수 모델에서   
공개 변수 스코프에 추가되는 멤버이다. 생성자 멤버에 접근할 때는 생성자를  
통해 접근하면 된다.   
```javascript
var obj = ...;
var proto = Object.getPrototypeOf(obj);
```
프로토 타입 객체에 정의되는 멤버를 프로토타입 멤버(prototype member)라  
하는데, 뒷절에서 자세히 기술한다.   
각 유형의 멤버는 표로 책 p.145에 자세히 나와있다.   

# 멤버 관리 구조   
멤버에 접근하는 방법은 두가지가 있다.  
```javascript
obj.member = 10;
//후출하겠지만 멤버는 배열이기 때문에 이런 접근이 가능하다.
obj['member'] = 10; 
```

# 연상 배열 구조   
객체별로 자신에게 속한 멤버를 관리하는 내부적인 데이터 구조가 있다. 객체의  
멤버(속성, 메서드)는 키, 값 쌍으로 구성된 집합이고, 각 멤버는 정렬돼 있지  
않다. 이러한 데이터를 관리하는 데 가장 적합한 데이터 구조로 해시가 있는데,   
JS는 해시구조의 일종인 연상 배열(associative array)라는 데이터 구조를 사용  
한다.  

# 연상 배열 요소의 접근  
JS 객체는 멤버를 관리할 때, 요소의 순서가 없는 연상 배열 구조를 이용한다.     
키값으로 문자열만 사용 가능하다. 키값은 unique해야 하며, 값은 어떤 타입의  
데이터도 저장할 수 있다.    
이 연상배열구조 때문에 이름은 고유해야 한다. 그래서 JS는 오버로드(overloa  
ding) 개념을 지원하지 않는다.  

# 객체 멤버 관리구조   
```javascript
mySon.setNewName('이름');
```
JS 엔진은 위 표현을 만나게 되면 mySon에 저장된 값이 참조 타입임을 알게   
되고, 이 참조값이 가리키는 연상 배열 구조의 객체로 이동해 setNewName 멤버를  
찾는다. 이 멤버가 참조타입 변수라는 사실을 알게되면 해당 변수값이 가리키는  
곳으로 간다. 그 후, 찾은 멤버에서 `()연산자`와 전달된 인자로 코드 블록을   
호출하고, 함수의 코드 블록이 파싱과 실행 단계를 거치게 된다.   

# 리플렉션   
현재 객체를 기반으로 타입을 추적하는 과정을 리플렉션(reflection)이라 한다.  
JS는 최소한으로 객체의 타입에 대한 정보를 런타임에 제공할 수 있다.   

# 멤버 === var 변수   
JS 객체 멤버는 속성이든 메서드든 모두 var 변수이다. 그래서 멤버 이름만   
보고도 이 것이 속성인지 메서드인지 적절한 이름을 부여하는 것이 다른 언어  
보다 중요하다.   






# 생성자 멤버와 객체 멤버   
생성자도 객체라서 일반 객체처럼 속성과 메서드를 추가할 수 있다. 생성자    
멤버는 생성자가 생성한 객체의 멤버와는 별도의 연상 배열 구조에서 관리된다.  
객체 멤버는 다시 인스턴스 멤버와 프로토타입 멤버로 구분되는데, 이 멤버가   
정의되는 영역은 다르다.     
생성자 멤버와 프로토타입 멤버가 정의되는 곳은 각각 함수별로(생성자 별로)  
하나만 존재한다.  
생성자 멤버, 프로토타입 멤버, 인스턴스 멤버는 각 영역에서 연상 배열 구조를  
이용하여 관리된다.   

# 멤버 접근, 관리  
객체 멤버에 접근하고 객체 멤버를 추가, 제거하는 법을 알아보자.   

## 멤버접근   
멤버 관리 구조만 생각하면 `[]`를 이용해 멤버에 접근하는 것은 당연한 것이고,   
`.`을 이용해 접근하는 것은 오히려 객체지향적인 표현을 위해 추가된 부차적인   
기능으로 볼 수 있다.   
  
생성자도 객체이기 때문에 일단 객체처럼 속성과 메서드를 추가할 수 있다.  
생성자 멤버는 인스턴스 멤버와 별도의 연상 배열 구조에서 관리되기 때문에   
다음과 같은 코드는 에러가 난다.   
```javascript
//Person 생성자에 Description 속성 추가   
Person.Description = "i am a person function";
Person.Description; //출력  
//Person으로 생성한 인스턴스 obj 에도 Description 속성이 추가될까   
var obj = new Person();
alert(obj.Description); //에러   
```
  
---

# Object.getPrototypeOf()
Object.getProtoTypeOf() 메서드는 지정된 객체의 프로토타입(가령 내부 Proto  
type 속성값)을 반환한다.  

## 구문  
```
Object.getPrototypeOf(obj);
```
## 매개변수   
obj : 자신의 프로토타입이 반환되는 객체   
## 예  
```javascript
var proto = {};
var obj = Object.create(proto);
Object.getPrototypeOf(obj) === proto; //true
```
## 주의   
ES5에서, obj 매개변수가 객체가 아닌 경우 TypeError 예외가 발생한다.   
ES6에서 매개변수는 Object로 강제된다.   
```javascript   
Object.getPrototypeOf("foo");
//TypeError: "foo"는 객체가 아닙니다 (ES5 코드)  
Object.getPrototypeOf("foo");
//String.prototype (ES6 코드)
```


























