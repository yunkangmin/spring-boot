프로그램이 복잡하다는 것은 수많은 객체들의 상호작용이 있다는 뜻이다.  
이 때 프로그램의 어떤 루틴이 또 다른 루틴의 값을 읽어 오려 할 때 값을 줄 준비가  
되지 않았다면 멈추게 될 것이다.  
사용자 입장에서는 방응성이 좋지 못한 결과를 가져오는 것이다.  
여기서 동시성 프로그램밍이라는 개념이 나타난다.  
전통적으로 여러 개의 실행 루틴을 동작시키는 멀티 스레드를 사용하곤 했지만 디버깅이 어렵고  
컴퓨팅 환경에 따라 결과를 예측하기 힘든 단점이 있었기 때문에 좀 더 다루기 쉬운 코루틴이 나타났다.  

## 11-1 동시성 프로그래밍
프로그래밍에서 순서대로 작업을 수행하여 1개의 루틴을 완료한 후 다른 루틴을 실행하는 방식을 동기적으로  
수행한다고 말한다.  
현재의 프로그래밍은 순차적인 프로그램보다 다양한 기능이 한꺼번에 일어나는 다중 실행 환경에 있는 경우가 많아졌다.  
예를 들면 화면에서 로딩되는 UI를 보여줄 때 네트워크는 데이터를 다운로드해야 하고 목록을 끌어올리면 지속적으로 UI를  
갱신하며 아이템 목록을 업데이트하는 경우가 대표적인 다중 작업 프로그램이다. 
이렇듯 여러 개의 루틴이 선행 작업의 순서나 완료 여부와 상관없이 실행되는 방식을 비동기적이라고 한다.  
이러한 비동기 프로그래밍은 RxJava, Reactive와 같은 서드파티 라이브러리에서 제공하고 있다.  
  
서드파티 라이브러리란 기본으로 제공되는 표준 라이브러리가 아닌 다른 개발자(제3자)가 만든 라이브러리를 말한다.  
개발을 편리하게 해주는 플러그인, 프레임워크, 유틸리티 API등을 제공하고 있다.  
  
코틀린에서는 코루틴을 서드파티가 아닌 기본으로 제공하고 있다.  
하나의 개별적인 작업을 루틴(routine)이라고 부르는데 코루틴이란 여러 개의 루틴들이 협력(co)한다는 의미로 만들어진  
합성어이다.  
순차적으로 루틴을 실행하는 동기 코드는 코드의 복잡도가 낮다.  
하지만 코드의 여러 구간에서 요청된 작업이 마무리가 될 때까지 멈춰 있는 현상이 나타나게 된다.  
이를 블로킹된 코드라고 부른다.  
여기저기 블로킹된 코드를 개선하고 성능을 향상시키려면 넌블로킹 기번의 코드를 구성해야 한다.  
보통 다중 작업을 하려면 스레드와 같은 비동기 코드를 작성해야 하는데 이 때 코드가 복잡해진다.  
하지만 코틀린의 코루틴을 사용하면 넌블로킹 또는 비동기 코드를 마치 동기 코드처럼 쉽게 작성하면서도  
비동기 효과를 낼 수 있다.  

### 블로킹과 넌블로킹
#### 블로킹 동작
다음 다이어그램을 보고 블로킹 동작을 이해해보자.  
![image](https://user-images.githubusercontent.com/33191974/126434378-bbe8a243-1d85-4bfb-b0c2-82722049a258.png)  
다음은 2개의 태스크(Task)가 있는 일반적인 형태의 프로그램 흐름이다.  
먼저 태스크 A에서 블로킹 구간을 발견할 수 있다.  
입출력 과정인 읽기나 쓰기(R/W) 과정이 수행될 때 태스크 A의 코드가 더 이상 진행되지 않고 내부 메모리 영역에서 해당 작업이  
마무리될 때까지 코드는 멈추게 된다. 이런 상황을 코드가 '블로킹'하고 있다고 말한다.  
태스크 A가 블로킹하는 동안 운영체제의 스케줄링 정책에 따라 우선순위가 낮은 또 다른 태스크 B가 실행될 수 있다.  
우선순위가 높은 태스크 A의 실행이 재개되면 우선순위가 낮은 태스크 B는 블로킹하고 태스크 A가 종료되면 다시 태스크 B가 재개된다.  

#### 넌블로킹 동작
![image](https://user-images.githubusercontent.com/33191974/126435027-57189237-ae7b-4517-9fba-e1a504ff9d55.png)  
넌블로킹 형태의 프로세스에서는 입출력 요청을 하더라도 운영체제에 의해 EAGAIN과 같은 시그널을 태스크 A가 받아서 실행을 재개할 수 있다.  
이 때 태스크 A는 다른 루틴을 수행하다가 내부적으로 입출력 완료 시그널을 받은 후 콜백 루틴등을 호출해 완료된 이후의 일을 처리할 수 있다.  
이러한 처리는 코드의 흐름을 멈추지 않고 다른 루틴을 먼저 수행할 수 있기 때문에 실행 시간이 더 빠르고 좀 더 좋은 성능을 보여준다.  
태스크 A를 수행하는 도중에 또 다른 태스크 B가 생성될 수 있는데 이 때 태스크 A와 B는 비동기적으로 수행될 수 있다.  
이 경우에는 A와 B의 실행 시점이 운영체제에 의해 결정되기 때문에 어떤 것이 어떻게 수행될지는 프로그래머가 알 수 없고 2개의 태스크 사이에  
운영체제의 스케줄링 기법에 의해 결정된다. 
위 다이어그램에서는 2개의 태스크가 동시에 수행되는 것처럼 보이나 프로세서 코어 수에 따라 동시에 수행될 수도 있고 2개의 태스크를 자주  
교환해 동시에 수행되는 것처럼 보이게 할 수도 있다.  
여러 개의 코어가 태스크가 동시에 수행되는 것을 병행 수행이라고 한다.



### 코틀린 코루틴(coroutine) 개념 익히기
코루틴은 코틀린만의 것이 아니다.  
이름이 비슷해서 코틀린의 것이라고 생각할 수 있지만 파이썬, c#, Go, Javascript등 여러 언어에서 지원하고  
있는 개념이다.  
Javascript를 사용하고 있으면서 async await를 사용하고 있다면 이미 코루틴을 사용해본 경험이 있는 것이다.  
아무튼 코루틴은 새로운 개념, 새로운 기술이 아니라 프로그래밍이 세상에 나온 초창기부터 존재하던 개념이다.  

#### 코루틴이란
코루틴을 3가지 키워드 정도로 알아보자.
1. 협력형 멀티 태스킹
2. 동시성 프로그래밍 지원
3. 비동기 처리를 쉽게 도와줌

##### 협력형 멀티태스킹
협력형 멀티태스킹을 프로그래밍 언어로 표현하자면 Co + Routine이다.  
Co라는 접두어는 "협력", "함께"라는 의미를 지니고 있다.  
Routine은 하나의 태스크, 함수 정도로 생각하면 된다.  
즉, 협력하는 함수다.  
더 진도를 나가기 앞서 Routine에 대해서 좀 더 알아보자.  
  
Routine은 우리가 흔히 알고 있는 main routine와 sub routine이 존재하낟.  
이런 단어들이 생소할 수도 있지만 우리가 늘 작성하고 있는 코드들이다.

```java
//Main routine
public static void main(String[] args) {
   ...
   int addedValue = plusOne(10);
   ...
}

//Sub routine
int plusOne(int value) {
  int one = 1;
  int addedValue = value + one;
  
  return addedValue;
}
```
main 함수가 말 그대로 Main 함수다.  
메인이 되는 함수인 것이다.  
그리고 메인이 되는 함수는 다른 서브 함수인 plusOne을 호출한다.  
우리가 짜는 프로그램은 흔히 이렇게 되어있다.  
너무 익숙한 흐름이라 어려울 것이 전혀없다.  
  
그런데 이 Sub Routine을 살펴보면 한가지 특징이 있다.
![image](https://user-images.githubusercontent.com/33191974/126416503-3081f991-ba21-4107-bb9b-a9a588417919.png)  
Sub Routine은 루틴에 진입하는 지점과 루틴을 빠져나오는 지점이 명확하다.  
즉, 메인 루틴이 서브루틴을 호출하면 서브루틴의 맨 처음 부분에 진입하여 return 문을 만나거나 서브루틴의 닫는  
괄호를 만나면 해당 서브루틴을 빠져나오게 된다.  

다시 코드로 돌아가 보자(이번엔 코틀린 코드)

```kotlin
fun main() {
  ...
  val addedValue = plusOne(value);
  ...
}

fun pulsOne(value: int) {  //서브루틴 진입
  val one = 1
  val addedValue = value + one
  
  return addedValue  //return을 만나면 탈출
}
```
메인 쓰레드가 plusOne이라는 서브루틴에 진입한다.  
당연히 코드는 처음부터 진입이 되어 맨 윗줄부터 실행이 될 것이고  
그 아래 코드들을 실행하여 return 문을 만나면 서브루틴을 호출했던 부분으로 탈출한다.  
그리고 진입점과 탈출점 사이에 메인 쓰레드는 블락되어있다.
  
그러나 코루틴은 조금 다르다. 




















