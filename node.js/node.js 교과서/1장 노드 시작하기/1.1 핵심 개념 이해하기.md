# 노드의 이벤트 기반 동작 방식 
먼저 전역 컨텍스트인 main 함수가 호출 스택에 들어간다. 그 뒤 setTimeout이 호출 스택에 들어간다.   
호출 스택에 들어간 순서와 반대로 실행되므로 setTimeout이 먼저 실행된다. setTimeout이 실행되면  
타이머와 함께 run 콜백을 백그라운드로 보내고 호출스택에서 빠진다. 그 다음으로 main 함수가 호출 스택에서  
빠진다. 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보낸다. 이벤트 루프는 호출 스택이 비어 있으면  
태스크 큐에서 함수를 하나씩 가져와 호출스택에 넣고 실행한다. 호출스택으로 올려진 run은 실행되고,   
실행완료 후 호출 스택에서 비워진다. 이벤트 루프는 태스트 큐에 콜백 함수가 들어올 때까지 계속   
대기하게 된다.(이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출스택으로 부른다).    
  
# 이벤트 루프가 하는일 정리
1. 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다.  
2. 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출스택에 넣고 실행하고 태스크 큐에   
콜백 함수가 들어올 때까지 계속 대기한다.  

[예제 파일](https://github.com/zerocho/nodejs-book)  
1 장에서는 Node.js가 무엇인지, 어디에 쓰이는지, 누가 쓰고 있는지를 알아보고, 노드의 핵심 개념들을 다룬다.   
또한 노드와 비주얼 스튜디오 코드를 설치하는 방법도 알아본다.   
이번 장에서는 노드와 관련된 실습 코드가 나오지는 않지만, 노드의 핵심 개념에 대해 다루므로 꼭 읽어보기  
바란다. 많은 노드 입문자가 핵심 개념을 충분히 이해하지 못한 채 코딩부터 시작하다 어려움을 겪는다.  
만약 여러분이 이미 런타임, 이벤트 기반, 논블로킹 I/O, 실글 스레드 모델이 무엇인지 알고 있다면  
넘어가도 좋다.  

# 1.1 핵심 개념 이해하기
노드가 무엇인지에 대해서는 여러 가지 의견이 많지만, 어떠한 설명도 노드 공식 사이트의 설명보다 정확하지는  
않을 것이다. 노드의 공식 사이트(https://nodejs.org/ko/)에서는 노드를 다음과 같이 설명하고 있다.  
```
Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다. Node.js는 이벤트 기반, 논블로킹  
I/O 모델을 사용해 가볍고 효율적이다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리  
생태계이기도 하다.  

//참고
1. 자바스크립트란?
자바스크립트는 프로그래밍 언어이다.

2. 자바스크립트 런타임이란?
- 런타임이란 프로그래밍 언어가 구동되는 환경을 말한다.
- 자바스크립트 런타임이란 자바스크립트가 구동되는 환경을 말한다.
- 이러한 자바스크립트 런타임의 종류로는 웹 브라우저(크롬, 파이어폭스, 익스플로러등) 프로그램과 Node.js라는  
프로그램이 있다.
- 이러한 프로그램들에서 자바스크립트가 구동되기 때문에 자바스크립트 런타임이라고 한다. 

3. V8 엔진이란?
- V8은 자바스크립트 엔진 중 하나이다.
- V8은 오픈 소스 자바스크립트 엔진 중 하나이다.
- 자바스크립트와 *웹어셈블리(WebAssembly) 엔진이다.
- 크롬 웹 브라우저와 Node.js등에서 사용되고 있다. 
- V8은 자바스크립트를 바이트코드로 컴파일하고 실행하는 방식을 사용한다.  
```


여러분 중 대부분은 노드를 서버로 사용하는 방법을 익히기 위해 이 책을 읽고 있을 것이다.   
그렇기 때문에 공식 사이트의 노드 소개글에 서버라는 말이 없어서 당황스러울 수도 있다. 하지만 걱정하지 말자.  
서버라는 말이 없는 이유는 노드가 서버로만 사용되는 것이 아니기 때문이다.   
그래도 이 책에서는 전반적으로 노드를 서버로서 사용하는 방법에 대해 다룬다. 그리고 14장에서는 자바스크립트  
프로그램을 운영하는 런타임으로 사용하는 방법을 다룬다. 먼저 서버와 런타임이 무엇인지 알아보자.   

## 1.1.1 서버
노드를 통해 다양한 자바스크립트 애플리케이션을 실행할 수 있지만, 노드는 서버 애플리케이션을 실행하는 데  
제일 많이 사용된다.  
그럼 서버란 무엇이며, 어떤 역할을 할까? 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는  
컴퓨터 또는 프로그램을 말한다. 클라이언트란 요청을 보내는 주체로, 브라우저일 수도 있고, 데스크톱 프로그램일  
수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있다. 여러분이 평소에 사용하는  
웹 사이트나 앱을 생각해보자. 웹 사이트의 화면(HTML)은 어디에서 가져올까? 앱 설치 파일은 어디에서  
내려받는 것일까?  
<img src="https://user-images.githubusercontent.com/33191974/150122478-3066f672-56e6-4bd2-95da-81312caa62a2.png" width="30%" height="30%"/>     
예를 들어 길벗출판사의 웹 사이트를 방문한다고 생각해보자. 주소창에 길벗출판사의 웹 사이트 주소(https://www.gilbut.  
co.kr/)를 입력(**요청**)하면 브라우저는 그 주소에 해당하는 길벗출판사의 컴퓨터 위치를 파악한다. 그리고 그 컴퓨터에서  
길벗출판사의 웹 사이트 페이지를 받아와 요청자의 브라우저(클라이언트)에 띄워준다(**응답**). 이런 일을 하는 컴퓨터가   
바로 서버이다.  
  
모바일 앱을 설치하는 경우를 생각해보자. 구글의 플레이 스토어나 애플의 앱스토어에서 원하는 앱을 골라서 설치 버튼을   
누르면(요청) 내려받기(응답)가 시작된다. 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 여러분이 그곳에서 데이터를  
받아와 모바일 기기에 설치할 수 있는 것이다. 그 어딘가가 구글과 애플의 서버이다. 플레이 스토어와 앱스토어는 클라이언트  
역할을 하는 것이다.  
  
웹이나 앱을 사용할 때 여러분의 데이터(아이디, 비밀번호, 이메일 등)와 서비스의 데이터가 생성된다. 이 데이터를 어딘가에   
저장하고, 그 어딘가에서 클라이언트로 데이터를 받아와야 한다. 이 곳이 바로 서버이다.   
  
서버라고 해서 요청에 대한 응답만 하는 것은 아니다. 다른 서버에 요청을 보낼 수도 있다. 이 때는 요청을 보낸 서버가  
클라이언트 역할을 한다.  
  
정리하면, 서버는 클라이언트의 요청에 대해 응답을 한다. 응답으로 항상 Yes를 해야 하는 것은 아니고, No를 할 수도 있다.   
여러분이 어떤 사이트로부터 차단 당했다면 그 사이트의 서버는 여러분의 요청에 매번 No를 응답할 것이다.  
  
노드는 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다. 다른 언어를  
사용하지 않고 왜 굳이 노드를 사용해 서버를 만드는지 의문이 들수도 있다. 궁금증을 해결하려면 먼저 노드의 특성에 대해  
알아야 한다. 공식 사이트에 게시된 노드 소개글을 바탕으로 노드의 특성에 대해 알아보자.   

## 1.1.2 자바스크립트 런타임
공식 사이트에 게시된 노드 소개글을 다시 한 번 보자.  
```
Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다.  
Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적이다.  
Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계  
이기도 하다.
```
노드는 자바스크립트 런타임이다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수   
있는 환경을 뜻한다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수  
있게 해준다.    
  
기존에는 자바스크립트 프로그램을 인터넷 브라우저 위에서만 실행할 수 있었다.  
브라우저 외의 환경에서 자바스크립트를 실행하기 위한 여러 가지 시도가 있었으나  
자바스크립트의 실행 속도 문제 때문에 모두 큰 호응을 얻지는 못했다.  
  
하지만 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하자 이야기가 달라졌다.  
당시 V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐고, 오픈 소스로 코드도  
공개되었다. 속도 문제가 해결되자 라이언 달(Ryan Dahl)은 2009년 V8 엔진기반의  
노드 프로젝트를 시작했다.    
노드의 내부구조  
<img src="https://user-images.githubusercontent.com/33191974/150125492-62b6b918-6e02-40b4-9f52-90f7f95dbca2.png" width="30%" height="30%"/>     
노드는 V8과 더불어 libuv라는 라이브러리를 사용한다. V8과 libuv는 C와 C++로 구현되어  
있다. 여러분이 코딩한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해주므로  
노드를 사용할 때 C와 C++는 몰라도 된다.  
  
libuv 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있다.  
노드는 스스로를 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적이라고  
표현했다. 그럼 이 모델이 무엇인지, 그리고 장단점으로는 어떤 것들이 있는지  
알아보자.   

## 1.1.3 이벤트기반  
이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는  
방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다.  
  
이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야  
한다. 이 것을 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고  
표현한다. 버튼을 누르면 경고창을 띄우도록 설정하는 것을 예로 들어보겠다.  
클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록해두면 클릭 이벤트가  
발생할 때마다 콜백 함수가 실행돼 경고창이 뜨는 것이다. 
   
노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔  
콜백 함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면  
노드는 다음 이벤트가 발생할 때까지 대기한다.  
  
<img src="https://user-images.githubusercontent.com/33191974/150126968-e155e2de-6a18-4319-9f92-9a78aff958f4.png" width="50%" height="50%"/>    
이벤트 기반 모델에서는 이벤트 루프라는 개념이 등장한다. 여러 이벤트가 동시에  
발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다. 이 책은  
여러분이 자바스크립트의 기초 지식을 알고 있다고 가정하므로 이벤트 루프 역시  
이미 알고 있다고 생각하고 넘어갈 것이다. 하지만 노드와 자바스크립트에서 이벤트  
루프는 정말 중요한 개념이니 간략히만 설명하도록 한다.   
  
노드는 자바스크립트 코드에서 맨 위부터 한 줄씩 실행한다. 함수 호출 부분을 발견했다면  
호출한 함수를 호출 스택에 넣는다. 다음 코드가 콘솔(브라우저 콘솔을 사용하면 된다.  
크롬의 경우 F12를 눌렀을 때 나오는 개발자 도구의 Console 탭이다.)에 어떤 로그를  
남길지 예측해보자. 만약 예측하기 여럽다면 자바스크립트를 복습해야 한다.  
```
function first() {
  second();
  console.log('첫 번째');
}

function second() {
  third();
  console.log('두 번째');
}

function third() {
  console.log('세 번째');
}
first();
```
first함수가 제일 먼저 호출되고, 그 안의 second 함수가 호출된 뒤, 마지막으로  
third 함수가 호출된다. 호출된 순서와는 반대로 실행이 된다. 따라서 콘솔에는  
세 번째, 두 번째, 첫 번째 순으로 찍히게 된다. 이를 쉽게 파악하는 방법은  
호출 스택을 그려보는 것이다.  
그림 1-5 호출 스택  
<img src="https://user-images.githubusercontent.com/33191974/150128655-02d3a7f7-5d4d-468a-a8af-21254663ad1b.png" width="50%" height="50%"/>  
그림 1-5에서 main 함수는 처음 실행 시의 전역 컨텍스트를 의미한다. 컨텍스트는  
함수가 호출되었을 때 생성되는 환경을 의미한다. 자바스크립트는 실행 시 기본적으로  
전역 컨텍스트 안에서 돌아간다고 생각하는게 좋다. 함수의 실행이 완료되면 호출 스택에서  
지워진다. third, second, first, main 순으로 지워지고, main 함수까지 실행이 모두  
완료되었다면 호출 스택은 비어있게 된다.  
콘솔의 출력 결과는 다음과 같다.   
```
세 번째
두 번째
첫 번째
```
이번에는 특정 밀리초(1000분의 1초) 이후에 코드를 실행하는 setTimeout을 사용하겠다.  
콘솔에 어떤 로그가 기록될지 예측해보자.  
```
function run() {
  console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```
결과는 다음과 같다.  
```
시작
끝
3초 후 실행
```
3초 뒤에 run 함수를 실행하는 코드이다. 콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는  
힘들다. setTimeout 함수의 콜백인 run이 호출 스택에 언제 들어가는지 알기 어렵기 때문이다.   
이를 파악하기 위해서는 이벤트 루프, 태스트 큐, 백그라운드를 알아야 한다.   
- 이벤트 루프 : 이벤트 발생 시 호출한 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는  
역할을 담당한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불린다.  
- 태스크 큐 : 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간이다. 콜백들이 이벤트 루프가  
정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부른다.  
- 백그라운드 : 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳이다.  

그림 1-6은 코드가 실행되는 내부 과정을 묘사한 그림이다.   
그림 1-6 이벤트 루프 1   
<img src="https://user-images.githubusercontent.com/33191974/150135126-bb2b34a2-31cd-4677-8907-97521cbcbc52.png" width="50%" height="50%"/>    
먼저 전역 컨텍스트인 main 함수가 호출 스택에 들어간다. 그 뒤 setTimeout이 호출 스택에 들어간다.   
  
호출 스택에 들어간 순서와 반대로 실행되므로 setTimeout이 먼저 실행된다. setTimeout이 실행되면 타이머와 함께  
run 콜백을 백그라운드로 보내고 호출 스택에서 빠진다. 그 다음으로 main 함수가 호출 스택에서 빠진다.  
백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보낸다.  
  
그림상으로는 태스크 큐가 하나의 큐처럼 보이지만 실제로는 여러 개의 큐로 이루어져 있다.  
이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다. 더 자세히 공부하고 싶다면 1.5절의 이벤트 루프  
설명에 대한 자료를 참고하자.   
  
그림 1-7은 호출 스택에서 main까지 실행이 완료되어 호출 스택이 비어 있는 상황이다. 이벤트 루프는 호출 스택이  
비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행한다.  
그림 1-7 이벤트 루프 2  
<img src="https://user-images.githubusercontent.com/33191974/150142870-17e7f45a-65f8-44da-bb47-c5a5e284f624.png" width="50%" height="50%"/>   
그림 1-8은 이벤트 루프가 run 콜백을 태스크 큐에서 꺼내 호출 스택으로 올린 상황이다. 호출 스택으로 올려진  
run은 실행되고, 실행 완료 후 호출 스택에서 비워진다. 이벤트 루프는 태스트 큐에 콜백 함수가 들어올 때까지  
계속 대기하게 된다.  
<img src="https://user-images.githubusercontent.com/33191974/150143518-79fc069a-be84-4374-8eef-7e16be356048.png" width="50%" height="50%"/>   
만약 호출 스택에 함수들이 너무 많이 차 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수도 있다.   
이벤트 루프는 호출 스택이 비어 있을 때만 태스트 큐에 있는 run 함수를 호출 스택으로 가져온다.  
이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유다.  

## 1.1.4 논블로킹 I/O
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다. 오래 걸리는 함수를 백그라운드로 보내서  
다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식이다.  
이 방식이 논블로킹 방식이다. 논블로킹이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻한다.  
그림 1-9 블로킹과 논블로킹   
<img src="https://user-images.githubusercontent.com/33191974/150145966-a00be96c-a7c2-4f38-afc4-bc8d30164204.png" width="30%" height="30%"/>  
그림 1-9를 보면 블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간 동안 처리할 수 있음을 알 수 있다.  
하지만 싱글 스레드라는 한계 때문에 자바스크립트의 모든 코드가 이 방식으로 시간적 이득을 볼 수 있는 것은 아니다.  
현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업이 주로 시간적 이득을 많이 본다.   
  
I/O는 입력(Input)/출력(Output)을 의미한다. 파일 시스템 접근(파일 읽기, 쓰기, 폴더 만들기등)이나 네트워크 요청 같은  
작업이 I/O의 일종이다. 이러한 작업을 할 때 노드는 논블로킹 방식으로 동작한다.   
  
블로킹과 논블로킹 말고도 동기와 비동기라는 개념에 대해서도 들어보았을 것이다. 이 개념은 코드를 보지 않고서는  
이해하기 어렵다. 동기와 비동기, 블로킹과 논블로킹의 관계는 3.6.1 절에서 코드와 함께 설명한다. 그 전까지는  
동기와 블로킹이 유사하고, 비동기와 논블로킹이 유사하다고만 알아두면 된다.  
  
다음 예제는 블로킹 방식의 코드이다. 콘솔 결과를 미리 예측해보자.   
```
function longRuniingTask() {
 //오래 걸리는 작업
 console.log('작업 끝');
}
console.log('시작');
longRunningTask();
console.log('다음 작업');
```
```
시작
작업 끝
다음 작업
```
작업을 수행하는데 오래 걸리는 longRunningTask 함수가 있다고 가정해보자.  
이 작업이 완료되기 전까지는 이어지는 console.log('다음 작업')이 호출되지 않는다.   
  
이번에는 setTimeout을 사용해서 코드를 바꿔보자. 논블로킹 방식의 코등이다.   
```
function longRunningTask() {
  //오래 걸리는 작업
  console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```
```
시작
다음 작업
작업 끝
```
setTimeout(콜백, 0)은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나이다. 노드에서는  
setTimeout(콜백, 0) 대신 다른 방식을 주로 사용한다(3.4.3절 참조). 이벤트 루프를 이해했다면  
setTimeout의 콜백 함수가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다.   
다음 작업이 먼저 실행된 후, 오래 걸리는 작업이 완료된다.  

> #### setTimeout(콜백, 0)  
> 밀리초를 0으로 설정했으므로 바로 실행되는 것이 아닌가 착각할 수 있다. 하지만 브라우저와  
> 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않는다. HTML5 브라우저에서는 4ms, 노드에서는  
> 1ms의 지연시간이 있다.

## 1.1.5 싱글 스레드
이벤트 기반, 논블로킹 모델과 더불어 노드를 설명할 때 자주 나오는 용어가 하나 더 있다.  
바로 싱글 스레드이다. 스레드를 이해하기 위해서는 프로세스도 알아야 하지만, 지금은 그냥 스레드가  
컴퓨터 작업을 처리할 수 있는 일손이라고 생각하면 된다. 조금 뒤에 자세히 알아보자.  
  
노드가 싱글 스레드라는 말을 들어봤는가? 노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다.  
반대로 멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있다.  
  
자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문이다. 한 번에 한 가지  
일 밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다.  
  
언뜻보면 여러 개의 일을 동시에 처리할 수 있기 때문에 멀티 스레드가 싱글 스레드보다 좋아 보인다.  
하지만 꼭 그런 것만은 아니다. 이해를 돕기 위한 예시를 하나 들어보자.  
  
한 음식점에 점원이 한 명 있다. 손님은 여러 명이다. 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서  
요리가 나오면 손님에게 서빙을 한다. 그 후 다음 손님의 주문을 받는다. 이런 구조라면 다음 손님은  
이전 손님의 요리가 나올 때까지 아무것도 못하고 기다리고 있어야 한다. 이것이 바로 싱글 스레드(점원),  
블로킹 모델이다. 매우 비효율적이다.  
그림 1-10 싱글 스레드, 블로킹 모델  
<img src="https://user-images.githubusercontent.com/33191974/150309442-ff0602ad-4183-46e0-9a80-998b67c011cd.png" width="30%" height="30%"/>    
이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다.   
요리가 끝나길 기다리지 않고 주문이 들어왔다는 것만 알려주는 것이다. 주방에서 요리가 완료되면  
순서대로 손님에게 서빙한다. 주문한 순서와 서빙하는 순서가 일치하지 않을 수도 있다.  
이것이 싱글 스레드, 논블로킹 모델이다. 바로 노드가 채택하고 있는 방식이다. 점원은 한 명이지만  
혼자서 많은 일을 처리할 수 있다. 하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가  
생길 수 있다. 또한, 주문을 받거나 서빙을 하는데 시간이 오래 걸린다면 주문이 많이 들어왔을 때  
버거울 수 있다.    
그림 1-11 싱글스레드, 논블로킹 모델    
<img src="https://user-images.githubusercontent.com/33191974/150309717-1382c4c5-3f5f-4537-b056-d5d86c0a3dc5.png" width="30%" height="30%"/>    
멀티 스레드 방식에서는 손님이 올 때마다 점원이 한 명씩 맡아 주문을 받고 서빙한다. 언뜻 보면  
싱글 스레드보다 좋은 방법인 것 같지만, 장담점이 있다. 일단 손님 한 명당 점원도 한 명이면  
서빙 자체는 걱정이 없다. 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문이다.  
하지만 손님의 수가 늘어날수록 점원의 수도 늘어난다. 손님 수가 줄어들었을 때 일을 하지 않고   
노는 점원이 있다는 것도 문제가 된다. 점원을 새로 고용하거나 기존 직원을 해고하는 데는  
비용이 발생한다.  
그림 1-12 멀티 스레드, 블로킹 모델   
<img src="https://user-images.githubusercontent.com/33191974/150310412-d52ea660-1387-435d-ab84-8a67bbac768c.png" width="30%" height="30%"/>      
그렇다면 점원 여러명(멀티 스레드)이 모두 논-블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는  
의문이 들 수 있다. 실제로 그렇다. 노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을  
하게 할 수 있다. 하지만 엄밀히 말하면 멀티 스레딩이라기보다는 멀티 프로세싱에 가깝다.  
그럼 프로세스와 스레드의 차이에 대해 알아보자.   
- 프로세스는 운영체제에서 할당하는 작업의 단위이다. 노드나 인터넷 브라우저 같은 프로그램은 개별적인   
프로세스이다. 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.  
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 하나의 프로세스는 스레드를 여러 개 가질 수 있다.  
스레드들은 부모 프로세스의 자원을 공유한다. 즉, 같은 메모리에 접근할 수 있다.  
  
스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈이다.  
요청이 많이 들어오면 한 번에 하나의 요청을 처리한다. 블로킹이 심하게 일어나지만 않는다면 하나로도  
충분하다.  
  
사실 노드 프로세스도 내부적으로는 스레드를 여러 개 가지고 있다. 하지만 여러분이 직접 제어할 수 있는  
스레드는 하나뿐이므로 흔히 싱글 스레드라고 부르는 것이다.   
그림 1-13 스레드와 프로세스  
<img src="https://user-images.githubusercontent.com/33191974/150311982-19541576-9d8a-4b2a-8a4c-89116536f24a.png" width="30%" height="30%"/>    
노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했다.  
자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다. 4.5절의 cluster 모듈과 15.1.5절의 pm2 패키지에서  
멀티 프로세싱을 가능하게 하는 방법에 대해 알아보자.   











  



























