**cluster 모듈은 싱글 스레드인 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다.** 포트를 공유하는 노드  
프로세스를 여러 개 둘수도 있어 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게  
할 수 있다. 서버에 무리가 덜 가게 되는 셈이다. 예를 들어 코어가 8개인 서버가 있을 때, 노드는 보통 코어를  
하나만 활요한다. 하지만 cluster 모듈을 설정하여 코어 하나당 노드 프로세스 하나가 돌아가게 할 수 있다.  
성능이 꼭 8배가 되는 것은 아니지만 코어를 하나만 사용할 때에 비해 성능이 개선된다. 하지만 장점만 있는 것은  
아니며, 세션을 공유하지 못하는 등의 단점도 있다. 이는 Redis 등의 서버를 도입하여 해결할 수 있다.   
server1.js를 클러스터링 해보자.   
cluster.js  
```
const cluster = require('cluster');
const http = require('http');
const { setTimeout } = require('timers');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    console.log(`마스터 프로세스 아이디: ${process.pid}`);
    //CPU 개수만큼 워커를 생산
    for (let i = 0; i < numCPUs; i+= 1) {
        cluster.fork();
    }
    //워커가 종료되었을 때
    cluster.on('exit', (worker, code, signal) => {
        console.log(`${worker.process.pid}번 워커가 종료되었습니다.`);
    });
} else {
    //워커들이 포트에서 대기
    http.createServer((req, res) => {
        res.write('<h1>Hello Node!</h1>');
        res.end('<p>Hello Cluster!</p>');
    }).listen(8085);

    console.log(`${process.pid}번 워커 실행`);
}
```
**클러스터에는 마스터 프로세스와 워커 프로세스가 있다. 마스터 프로세스는 CPU 개수만큼 워커 프로세스를 만들고,   
8085번 포트에서 대기한다. 요청이 들어오면 만들어진 워커 프로세스에 요청을 분배한다.**  
  
워커 프로세스가 실질적인 일을 하는 프로세스이다. 여기서는 실험한 컴퓨터 CPU 코어의 개수가 4개라서 워커가 4개 생성된다.  
실제로 4개가 생성되는지 확인해보자.  
  
코드를 다음과 같이 수정한다.  
cluster.js  
```
//워커들이 포트에서 대기
http.createServer((req, res) => {
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Cluster!</p>');
    setTimeout(() => {
        //1은 에러가 발생해서 종료한다는 뜻
        process.exit(1);
    }, 1000);
}).listen(8085);
```
요청이 들어올 때마다 1초 후에 서버가 종료되도록 했다. 이제 서버를 실행한다. process.pid는 매 실행시 마다 달라진다.  
각자 자신의 코어 개수에 맞게 워커가 실행되는지 확인해보자.   
콘솔  
```
PS C:\nodejs\js\4http> node cluster
마스터 프로세스 아이디: 8020
13304번 워커 실행
5144번 워커 실행
25836번 워커 실행
14296번 워커 실행
```
http://localhost:8085에 접속하면 1초 후 콘솔에 워커가 종료되었다는 메시지가 뜬다. 네번 새로고침을 하면 이제 모든 워커가  
종료되어 서버가 응답하지 않는다.  
콘솔  
```
14296번 워커가 종료되었습니다.
25836번 워커가 종료되었습니다.
5144번 워커가 종료되었습니다.
13304번 워커가 종료되었습니다.
```
즉, 네번까지는 오류가 발생해도 서버가 정상 작동할 수 있다는 뜻이다. 종료된 워커를 다시켜면 오류가 발생해도 계속 버틸 수 있다.  
다음과 같이 워커 프로세스가 종료되었을 때 새로 하나를 생성해보자.  
cluster.js  
```
...

//워커가 종료되었을 때
cluster.on('exit', (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커가 종료되었습니다.`);
    cluster.fork();
});

...
```
콘솔  
```
26232번 워커가 종료되었습니다.
15804번 워커 실행
15804번 워커가 종료되었습니다.
26196번 워커 실행
```
이제 워커가 죽을 때마다 새로운 워커가 하나 더 생성된다. **하지만 이러한 방식을 오류를 막으려는 것은 좋지 않은 생각이다.  
오류 자체의 원인을 찾아 해결해야 한다. 그래도 예기치 못한 에러로 인해 서버가 종료되는 현상을 방지할 수 있어  
클러스터링을 적용해두는 것이 좋다.**  
  
직접 clustr 모듈로 클러스터링을 구현할 수도 있지만, 실무에서는 pm2 등의 모듈로 cluster 기능을 사용하곤 한다.  
pm2 모듈은 15.1.5절에서 설명한다.  
  
다시 REST API와 라우팅으로 돌아가보자. 4.3절의 웹 서버 주소는 크게 HTML 또는 CSS 파일을 요청하는 주소와 서버의  
users 자원을 요청하는 주소로 나뉘어져 있다. 만약 파일이나 자원의 수가 늘어나면 그에 따라 주소의 종류도 많아져야 한다.  
  
그런데 이미 코드가 상당히 길어 보기도 어렵고 관리하기도 어렵다. 주소의 수가 많아질수록 코드는 계속 길어진다.  
여기에 쿠키와 세션을 추가하게 되면 더 복잡해질 것이다. 이를 편리하게 만들어주는 모듈이 있다. 바로 Express 모듈이다.  
Express 모듈은 다른사람들이 만들어둔 모듈이므로 설치해야 사용할 수 있다.  
  
다음 장에서는 다른 사람의 모듈을 설치할 수 있게 해주는 npm에 대해 알아보고 npm에서 모듈을 설치하는 방법도 알아보자.  































