# ES6란?
ES6(ECMAScript 2015)는 최신 자바스크립트 문법이자 스펙이다. ECMA에서 자바스크립트의  
첫 표준을 제정한 이래 2015년에 문법적으로 가장 큰 변화가 있었다. 이렇게 변경된 자바스크립트를  
ECMAScript 2015 또는 ES6라고 부르고, 기존 자바스크립트를 ES5라고 부른다. ES6는 개발자가  
더 쉽게 코드를 작성할 수 있도록 문법을 단순화하고, 미숙한 코딩으로 인한 오류를 미연에 방지하기 위해  
언어 자체에서 유효 범위를 제한하는 등의 기능을 추가했다.  
  
그럼 ES5와 ES6가 코드 상에서 어떻게 다른지 한번 확인해보자.  
```
//ES5
var num = 100;
var sumNumbers = function(a, b) {
  return a + b;
};
sumNumbers(10, 20);//30
```
```
//ES6
const num = 100;
let sumNumbers = (a, b) => {
  return a + b;
};
sumNumbers(10, 20); //30
```
위 코드는 둘 다 변수를 선언하고 2개의 숫자를 더하는 함수를 선언해서 10, 20을 더한 것을 출력하는 코드이다.   
먼저 왼쪽 코드는 ES5 코드이다. var로 num이라는 변수를 선언하여 100을 대입했고, sumNumbers라는 변수를  
선언한 다음에 인자 값 2개를 합산하는 함수 표현식을 정의했다. 오른쪽 ES6 코드도 const로 num이라는 변수를   
선언하고, ES6의 화살표 함수(=>)를 활용하여 인자값 2개를 받아 합산하는 함수 표현식을 정의했다.  
  
이렇게 변수를 선언한느 const, let과 함수를 정의하는 화살표 함수 방식 이외에도 많은 부분의 문법이 바뀌었다.  
여기서는 ES6 문법을 모두 다루지는 않고 뷰로 개발할 때 알면 도움이되는 몇 가지 주요 문법만 살펴본다.   

# const와 let 예약어
const와 let은 변수를 선언할 때 사용하는 예약어이다. ES5에서는 변수를 선언할 때 var를 사용하지만 ES6는 var 대신  
let으로 변수를 선언한다. 그리고 선언한 후 값이 바뀌지 않고 동일하게 사용되는 변수에 대해서는 const를 추가로  
사용할 수 있다. 이렇게 구분하는 이유는 변수를 선언할 때 변수의 용도를 미리 고민하고 변수의 성격에 따라 변수  
선언 방식을 구분함으로써 코드의 가독성을 높이기 위해서이다.    
  
다음의 코드를 통해 const와 let의 특징을 구분할 수 있다.  
할당한 값을 변경할 수 있는 let  
```
let a = 10;
a = 20; //20
```
값의 갱신을 허용하지 않는 const  
```
const a = 10;
a = 20;  //Uncaught TypeError: Assignment to constant variable.
```
위 두 코드는 a라는 변수를 선언하고 숫자 10을 대입한 후 a에 다시 숫자 20을 할당하는 코드이다. let은 정상적으로 a의  
값이 20으로 다시 할당되지만 const는 값을 다시 할당하려고 하면 오류가 발생한다. 그 이유는 const 예약어로 선언한 변수에  
한 번 할당된 값은 다시 변경할 수 없기 때문이다. 따라서 상수값과 함수를 정의할 때는 const를 활용하고, 반복문을 비롯한   
나머지 변수를 선언할 때는 let을 활용하는게 좋다.  

# 블록의 유효 범위
두 번째로 살펴볼 특징은 블록의 유효 범위(block scope)이다. 아래 코드를 통해 차이점을 알아보자.  
ES5에서 블록의 유효범위   
```
var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4
}
console.log(i);// 5
```
ES6에서 블록의 유효범위  
```
let i = 10;
for (let i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4
}
console.log(i); //10
```
ES5로 작성한 코드를 크롬 개발자 도구의 Console 패널에서 실행하면 0, 1, 2, 3, 4, 5가 출력된다.   
ES5 문법의 기본적인 특징 중 하나가 '변수의 유효 범위가 블록 단위로 제한되지 않는다'라는 점이다.   
따라서 var i = 10;으로 변수 i 값을 선언한 상태에서 for문의 초기값에 var i = 0을 선언하면  
for 문 밖에서 선언했던 변수 i의 값을 다시 선언하는 것과 같은 효과가 나타난다. 따라서 for문이  
끝나고 난 후 {} 밖에서 console.log(i);를 실행하면 for문의 최종 실행 결과가 출력된다.   
  
반대로 ES6의 출력 결과는 for문 실행이 끝난 후에도 for문을 실행하기 전의 값인 10이 동일하게 출력된다.  
for문에서 초기값을 let으로 선언했기 때문에 let i = 0;의 유효범위가 for문 내부로 제한된 것이다.    

# 화살표 함수
화살표 함수(Arrow Functions)는 기존 ES5의 함수 정의 방식을 간소화한 문법이다. 아래 코드를 함께 살펴보자.   
ES5에서 함수 정의 방식  
```
var sumNumbers = function(a, b) {
  return a + b;
}
```
ES6에서 함수 정의 방식   
```
var sumNumbers = (a, b) => {
  return a + b;
};
```
위 코드는 앞에서 보았듯이 인자 값 2개를 합산하는 함수 표현식이다. sumNumbers(10, 20)를 실행하면 두 코드의  
결과값이 30으로 똑같다. 이렇게 함수를 선언할 때 function()으로 길게 선언할 필요없이 => 로 간단하게 선언할  
수 있다. 이와 같은 방식으로 코드를 구성하면 구현 속도도 빨라지고 코드의 전체 길이도 짧아진다.  
  
# Import와 Export
import와 export는 자바스크립트 모듈화와 관련된 기능이다. 모듈화란 코드를 특정 기능이나 로직 단위로 구분하여  
각각의 모듈로 관리하는 것을 말한다. 각 모듈은 다른 모듈에 영향을 주지 않고 독립적으로 실행할 수 있어야 한다.  
자바스크립트는 원래의 언어 자체에 이런 모듈화 기능이 없기 때문에 라이브러리나 프로그래밍 패턴 등으로 모듈화를  
지원해왔다. 예를 들어, CommonJS, RequireJS 등 모듈화를 지원하는 라이브러리를 이용해 원하는 시점에 특정   
자바스크립트 파일을 로딩하거나 독립적인 실행 영역을 보장받을 수 있다. 또는 다음과 같은 프로그래밍 패턴으로  
변수가 서로 충돌하는 것을 방지할 수 있다.   
프로그래밍 패턴으로 모듈화하는 코드  
```
var nameSpaceA = {
  num : 10
};

var nameSpaceB = {
  num : 20
};
console.log(nameSpaceA.num); //10
console.log(nameSpaceB.num); //20
```
위 코드는 모듈화 기법 중 네임스페이스(name space)를 활용하여 num 변수의 범위가 충돌하지 않게 모듈화하는 코드이다.   
이렇게 되면 num 값이 10과 20으로 각각의 네임스페이스에 보존된다. 여러 개의 자바스크립트 파일을 사용할 때 변수가  
서로 충돌하지 않게 하기 위해 사용하는 일반적인 프로그래밍 기법이다.   
  
하지만 매번 이렇게 변수의 유효 범위를 구분해 주기 위해 모듈화 패턴을 사용하는 건 번거롭다.   
이러한 수고를 덜어 주고자 ES6는 언어 자체에서 import와 export로 모듈화를 지원한다.   

> #### 자바스크립트에 모듈화가 필요한 이유
> 자바스크립트는 변수의 유효 범위가 파일 단위로 구분되지 않는다. 기본적으로 같은 유효 범위를 갖는다.   
> 그래서 복잡한 애플리케이션을 작성하다 보면 기존에 정의된 변수를 실수로 재정의하거나 유효 범위가  
> 충돌하는 경우가 발생한다. 따라서 이런 문제를 방지하기 위해 모듈화가 필요하다.  

import란 한 파일에서 다른 파일의 내용을 불러올 때 사용한다. export는 한 파일의 특정 기능을 다른 파일에서 사용할 수  
있도록 설정할 때 사용한다. 다음과 같이 말이다.   
import와 export의 예제  
```
//./app/login.js
export const id = 'test';

//./main.js
import { id } from './app/login.js';
console.log(id);
```
위 코드는 main.js 파일에서 app/login.js 파일의 id값을 불러와 콘솔로 출력하는 예제이다.   
main.js 파일을 **실행하는 시점**에 login.js 파일에 선언된 일부 내용(변수id)을 불러와 main.js 파일의 로직에서 사용했다.  

## 뷰 싱글 파일 컴포넌트 체계에서 import와 export 살펴보기
앞의 내용을 바탕으로 뷰 싱글 파일 컴포넌트 체계를 다시 살펴보자. webpack-simple 프로젝트에서 아래와 같은  
뷰 파일이 2개 있다고 가정하자.   
App.vue 파일  
```
<template>
  <div id="app">
    <Login></Login>
  </div>
</template>

<script>
import Login from './Login.vue';

export default {
  components : {
    'Login' : Login
  }
}
</script>
```
Login.vue 파일   
```
<template>
  <h1>로그인 컴포넌트</h1>
</template>
```
앞의 App.vue 파일에 컴포넌트로 등록된 Login 컴포넌트는 Login.vue 파일 내용과 동일하다.   
왜냐하면 import로 Login.vue 파일의 내용을 가져와서 Login이라는 객체에 담고, Login 객체를  
components 속성에서 컴포넌트로 등록했기 때문이다. 참고로, import 대상 파일에 export가 정의되어 있지 않으면   
기본적으로 파일의 모든 내용이 export 된다.  
  
여기서 Login.vue 파일의 내용을 보면 `<h1>`을 포함하는 간단한 `<template>`만 있다.  
따라서 npm run dev 명령어로 애플리케이션을 실행했을 때 App.vue 파일에 Login.vue 파일의 내용이  
포함되어 화면에 표시된다.    
App.vue 파일에서 Login.vue 파일의 내용을 import한 모습   
```
<!-- App.vue -->
<div id="app">
  //<Login>태그가 Login.vue 파일의 <h1>로그인 컴포넌트</h1>로 변경된다.
  <Login></Login>
</div>

<!-- Login.vue -->
<h1>로그인 컴포넌트</h1>
```
지금까지 뷰 개발에 도움되는 ES6 문법을 살펴봤다.  






  






















