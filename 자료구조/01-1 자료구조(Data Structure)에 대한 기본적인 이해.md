자료구조 서적의 첫 장을 열었다는 것만으로도 의미가 있다고 필자는 말해왔다.  
하지만 그 의미가 열매로 맺어지려면 포기하지 않아야 한다.  
그리고 포기하지 않으려면 다급한 마음을 버려야 한다.  
자료구조 학습에는 충분한 시간이 필요하다.  
이 사실을 잊지 말고 첫 Chapter의 문을 열자!

### C언의 문법과 관련해서 여러분이 알고 있다고 가정하는 부분
여러분도 알다시피 본서는 C언어를 도구로 하여 자료구조를 설명한다.  
때문에 C언어를 잘 이해하고 있다고 가정한다.  
가정하는 수준의 정도는 다음과 같다.  
- 구조체를 정의할 줄 알고 구조체 대상의 typedef 선언을 할 줄 안다. 
- malloc 함수와 free 함수를 사용할 줄 알고 이는 메모리의 동적 할당과 관련 있음을
  이해한다.
- 포인터 변수의 선언과 포인터 연산에 부담이 없다.
- 헤더파일이 필요한 이유를 이해한다.  
- 헤더파일을 정의할 줄 알고 헤더파일에 들어가야 할 것들이 무엇인지 알고 있다. 
- 헤더파일의 정의에 사용되는 매크로 #ifndef ~ #endif의 의미를 알고 있다.
- 하나의 프로그램을 둘 이상의 소스파일과 헤더파일에 나누어 담을 줄 안다.
- 재귀함수의 동작방식을 안다. 그리고 재귀함수와 관련된 아주 간단한 예제는 분석할 수 있다.

### 자료구조란 무엇인가?
우리가 공부할 자료구조라는 것이 무엇인지 이야기해보자.  
자료구조에서는 데이터를 표현하고 저장하는 방법에 대해서 설명한다.  
아마도 여러분은 C언어를 공부하면서 다음과 같은 이야기를 접한 적이 있을 것이다.  
  
"프로그램이란 데이터를 표현하고 그렇게 표현된 데이터를 처리하는 것이다."  
  
위에서 말하는 '데이터의 표현'은 '데이터의 저장'을 포함하는 개념이다.  
그리고 이렇듯 '데이터의 저장'을 담당하는 것이 바로 자료구조이다.  
사례를 들면 다음과 같다.  

"정수를 저장하기 위해서 int형 변수를 선언한다."  
"개인정보를 저장하기 위한 목적으로 구조체를 정의한다."  
  
넓은 의미에서 int형 변수도, 구조체의 정의도 자료구조에 속한다.  
int형 변수도, 구조체도 데이터를 표현 및 저장하는 하나의 방법이기 때문이다.  
뿐만 아니라 여러분은 배열을 선언해서 다양한 정보를 저장한 바 있다.  
즉, 배열도 자료구조의 일종이다.  
물론 우리가 본서에서 공부할 자료구조는 이렇듯 단순하지 않다.  
우리는 보다 복잡한 형태의 자료구조들에 대해 이야기할 것이다.  
그리고 이러한 자료구조는 기본적으로 다음과 같이 분류할 수 있다.  
![image](https://user-images.githubusercontent.com/33191974/128451489-fb60e553-dd06-452c-99fe-c5c7a25edcc4.png)
위 그림에서 보이듯이 파일도 데이터를 저장하는 도구이기 때문에 파일의 구조도(파일이 데이터를 저장하는 방식도) 자료구조에  
포함이 된다.  
하지만 보서를 통해서 공부할 대상은 선형구조와 비선형구조, 다시 말해서 '선형 자료구조'와 '비선형 자료구조' 이 두가지이다.  
선형 자료구조는 그 이름이 의미하듯이 자료를 표현 및 저장하는 방식이 선형(linear)이다.  
공대생이라면 '선형'이라는 단어를 접하는 순간 슈퍼포지션(superposition)과 호모지니어스(homogeneous)를 떠올릴지 모른다. 
그러나 여기서는 그런 어려운 단어를 떠올릴 필요가 없다.  
선형이라는 단어의 뜻 그대로 '선의 형태'로 이해하면 된다.  
즉, 선형 자료구조는 데이터를 선의 형태로 나란히 혹은 일렬로 저장하는 방식이다.  
그래서 여러분이 공부하기에 상대적으로 수월할 것이다.  
반면 비선형 자료구조는 그 이름이 의미하듯이, 데이터를 나란히 저장하지 않는 구조이다.  
따라서 선형 자료구조에 비해 상대적으로 수월하지 않을 것이다.  
  
### 자료구조와 알고리즘
앞서 말했듯이 자료구조가 '데이터의 표현 및 저장방법'을 뜻한다면,  알고리즘은 이렇듯 표현 및 저장된 데이터를 대상으로 하는  
'문제의 해결 방법'을 뜻한다.  
예를 들어서 다음의 배열 선언은 자료구조적 측면의 코드이다.  

```c
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
```
반면 배열에 저장된 모든 값의 합을 더하는 다음 반복문의 구성은 알고리즘적 측면의 코드이다.  
  
```c
//배열 arr과 변수 sum, idx가 선언되었다 가정
for (idx = 0; idx < 10; idx++)
   sum += arr[idx];
```
위의 반복문은 '배열에 저장된 모든 값의 합을 구하는 알고리즘'이라 할 수 있다.  
이렇듯 자료구조와 알고리즘은 밀접한 관계를 갖는다.  
자료구조가 결정되어야 그에 따른 효율적인 알고리즘을 결정할 수 있기 때문이다.  
만약에 값이 저장된 자료구조가 배열이 아니었어도 위에서 보이는 바와 같이 반복문과 인덱스 값을  
이용한 순차적 접근을 진행했을까?  
배열이 아니었다면 그 방법은 분명 달라졌을 것이다.  
다음 문장을 보면서 필자의 질문에 답을 하기 바란다.  
```
"여기 상자가 제법 많이 쌓여 있지요? 이 상자들 중 어딘가에 넣어 둔 머그컵을 찾으셔야 합니다."  
```
위의 문장에서 '쌓여있는 상자'는 자료구조이다.  
그렇다면 이 상자들을 대상으로 머그컵을 찾는 알고리즘은 어떻게 구성해야겠는가?  
```
딱 봐서 머그컵이 있을법한 상자를 꺼냅니다. 맨 아래에 있는 상자라도 말이죠."
```
위와 같이 답한 분은 없으리라 믿는다.  
상자가 쌓여 있으니 가장 위에 있는 상자부터 순서대로 내려서 찾아봐야 할 것 아닌가?  
이제 필자가 하고픈 말이 무엇인지 완전히 이해했을 것이다.  
```
"자료구조에 따라서 알고리즘은 달라진다."
"알고리즘은 자료구조에 의존적이다."
```





























  

















